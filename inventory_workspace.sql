  CREATE TABLE "HTMLDB_PLAN_TABLE" 
   (	"STATEMENT_ID" VARCHAR2(30), 
	"PLAN_ID" NUMBER, 
	"TIMESTAMP" DATE, 
	"REMARKS" VARCHAR2(4000), 
	"OPERATION" VARCHAR2(30), 
	"OPTIONS" VARCHAR2(255), 
	"OBJECT_NODE" VARCHAR2(128), 
	"OBJECT_OWNER" VARCHAR2(128), 
	"OBJECT_NAME" VARCHAR2(128), 
	"OBJECT_ALIAS" VARCHAR2(261), 
	"OBJECT_INSTANCE" NUMBER(*,0), 
	"OBJECT_TYPE" VARCHAR2(128), 
	"OPTIMIZER" VARCHAR2(255), 
	"SEARCH_COLUMNS" NUMBER, 
	"ID" NUMBER(*,0), 
	"PARENT_ID" NUMBER(*,0), 
	"DEPTH" NUMBER(*,0), 
	"POSITION" NUMBER(*,0), 
	"COST" NUMBER(*,0), 
	"CARDINALITY" NUMBER(*,0), 
	"BYTES" NUMBER(*,0), 
	"OTHER_TAG" VARCHAR2(255), 
	"PARTITION_START" VARCHAR2(255), 
	"PARTITION_STOP" VARCHAR2(255), 
	"PARTITION_ID" NUMBER(*,0), 
	"OTHER" LONG, 
	"DISTRIBUTION" VARCHAR2(30), 
	"CPU_COST" NUMBER(*,0), 
	"IO_COST" NUMBER(*,0), 
	"TEMP_SPACE" NUMBER(*,0), 
	"ACCESS_PREDICATES" VARCHAR2(4000), 
	"FILTER_PREDICATES" VARCHAR2(4000), 
	"PROJECTION" VARCHAR2(4000), 
	"TIME" NUMBER(*,0), 
	"QBLOCK_NAME" VARCHAR2(128)
   ) ;

  CREATE TABLE "KATALOG" 
   (	"ID_CZĘŚCI" NUMBER GENERATED ALWAYS AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"OPIS" VARCHAR2(255) NOT NULL ENABLE, 
	 CONSTRAINT "KATALOG_PK" PRIMARY KEY ("ID_CZĘŚCI")
  USING INDEX  ENABLE
   ) ;

  CREATE TABLE "MODELE" 
   (	"ID_MODELU" NUMBER GENERATED ALWAYS AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"OPIS" VARCHAR2(255) NOT NULL ENABLE, 
	"PODSTAWOWY_KOD" VARCHAR2(50), 
	 CONSTRAINT "MODELE_PK" PRIMARY KEY ("ID_MODELU")
  USING INDEX  ENABLE
   ) ;

  CREATE TABLE "PRODUKCJA" 
   (	"ID_PRODUKCJA" NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"ID_MODELU" NUMBER DEFAULT "WKSP_WORKSPACEINVENTORYMANAGEMENT"."PROD_ID_SEQ"."NEXTVAL" NOT NULL ENABLE, 
	"DATA" TIMESTAMP (6) DEFAULT systimestamp NOT NULL ENABLE, 
	"NR_SERYJNY" VARCHAR2(60 CHAR), 
	 CONSTRAINT "PRODUKCJA_PK" PRIMARY KEY ("ID_PRODUKCJA")
  USING INDEX  ENABLE
   ) ;

  CREATE TABLE "SPECYFIKACJE" 
   (	"ID_SPECYFIKACJI" NUMBER GENERATED ALWAYS AS IDENTITY MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 1 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  NOT NULL ENABLE, 
	"ID_CZĘŚCI" NUMBER NOT NULL ENABLE, 
	"ID_MODELU" NUMBER NOT NULL ENABLE, 
	"ILOŚĆ" NUMBER NOT NULL ENABLE, 
	 CONSTRAINT "SPECYFIKACJE_PK" PRIMARY KEY ("ID_SPECYFIKACJI")
  USING INDEX  ENABLE
   ) ;

  ALTER TABLE "PRODUKCJA" ADD CONSTRAINT "PRODUKCJA_CON" FOREIGN KEY ("ID_MODELU")
	  REFERENCES "MODELE" ("ID_MODELU") ON DELETE CASCADE ENABLE;

  CREATE OR REPLACE EDITIONABLE TRIGGER "PRODUKCJA_CREATION_T" 
before insert on "PRODUKCJA"
for each row
begin
    SELECT NEXT_PRODUCED_NUMBER(:new.id_modelu) INTO :NEW.nr_seryjny FROM dual;
end;
/
ALTER TRIGGER "PRODUKCJA_CREATION_T" ENABLE;

  ALTER TABLE "SPECYFIKACJE" ADD CONSTRAINT "SPECYFIKACJE_CZESCI_FK" FOREIGN KEY ("ID_CZĘŚCI")
	  REFERENCES "KATALOG" ("ID_CZĘŚCI") ENABLE;
  ALTER TABLE "SPECYFIKACJE" ADD CONSTRAINT "SPECYFIKACJE_FK" FOREIGN KEY ("ID_MODELU")
	  REFERENCES "MODELE" ("ID_MODELU") ENABLE;
create or replace FUNCTION calculate_forecast(mod_id IN NUMBER, horizon IN NUMBER)
  RETURN forecast_table_type AS
  l_current_value NUMBER;
  l_average NUMBER;
  l_max_date DATE;
  result forecast_table_type := forecast_table_type();
BEGIN
  SELECT LICZBA
  INTO l_current_value
  FROM MODELE_PRODUKCJA_COUNT_V
  WHERE ID_MODELU = mod_id;

  SELECT CURAVERAGE, MAXDATE
  INTO l_average, l_max_date
  FROM PRODUCTION_TOTAL_AVERAGE_AND_DEVIATION_V
  WHERE ID_MODELU = mod_id;

  FOR i IN 0..horizon LOOP
    result.extend();
    result(result.count) := forecast_type(l_max_date + i, l_current_value + i * l_average);
  END LOOP;

  RETURN result;
END calculate_forecast;
/
create or replace FUNCTION calculate_forecast_with_limits(mod_id IN NUMBER, horizon IN NUMBER)
  RETURN forecast_with_limits_table_type IS
  l_current_value NUMBER;
  l_average NUMBER;
  l_stddev NUMBER;
  l_max_date DATE;
  result forecast_with_limits_table_type := forecast_with_limits_table_type();
BEGIN
  SELECT LICZBA
  INTO l_current_value
  FROM MODELE_PRODUKCJA_COUNT_V
  WHERE ID_MODELU = mod_id;

  SELECT CURAVERAGE, CURDEVIATION, MAXDATE
  INTO l_average, l_stddev, l_max_date
  FROM PRODUCTION_TOTAL_AVERAGE_AND_DEVIATION_V
  WHERE ID_MODELU = mod_id;

  FOR i IN 0..horizon LOOP
    result.extend();
    result(result.count) := forecast_with_limits_type('UCL', l_max_date + i, l_current_value + i * l_average + 3 * l_stddev);
    result.extend();
    result(result.count) := forecast_with_limits_type('LCL', l_max_date + i, l_current_value + i * l_average - 3 * l_stddev);
  END LOOP;

  RETURN result;
END calculate_forecast_with_limits;
/
create or replace FUNCTION calculate_normcdf(mod_id IN NUMBER, points IN NUMBER, divisor IN NUMBER)
  RETURN point_table_type IS
  l_average NUMBER;
  l_deviation NUMBER;
  l_points NUMBER;
  l_points_middle NUMBER;
  result point_table_type := point_table_type();
BEGIN
  l_points := points + 1;
  l_points_middle := points / 2 + 1;

  SELECT CURAVERAGE, CURDEVIATION
  INTO l_average, l_deviation
  FROM (
    SELECT CURAVERAGE, CURDEVIATION
    FROM PRODUCTION_TOTAL_AVERAGE_AND_DEVIATION_V
    WHERE ID_MODELU = mod_id
    ORDER BY id_modelu
  )
  WHERE ROWNUM = 1;


  FOR i IN 1..l_points LOOP
    result.extend();
    result(result.count) := point_type((i - l_points_middle) / divisor, normcdf2((i - l_points_middle) / divisor, l_average, l_deviation));
  END LOOP;

  RETURN result;
END calculate_normcdf;
/
create or replace FUNCTION calculate_normpdf(mod_id IN NUMBER, points IN NUMBER, divisor IN NUMBER)
  RETURN point_table_type IS
  l_average NUMBER;
  l_deviation NUMBER;
  l_points NUMBER;
  l_points_middle NUMBER;
  result point_table_type := point_table_type();
BEGIN
  l_points := points + 1;
  l_points_middle := points / 2 + 1;

  SELECT CURAVERAGE, CURDEVIATION
  INTO l_average, l_deviation
  FROM (
    SELECT CURAVERAGE, CURDEVIATION
    FROM PRODUCTION_TOTAL_AVERAGE_AND_DEVIATION_V
    WHERE ID_MODELU = mod_id
    ORDER BY id_modelu -- choose a column to determine the "first" row
  )
  WHERE ROWNUM = 1;

  DBMS_OUTPUT.PUT_LINE('Average: ' || l_average);
  DBMS_OUTPUT.PUT_LINE('Deviation: ' || l_deviation);

  FOR i IN 1..l_points LOOP
    result.extend();
    result(result.count) := point_type((i - l_points_middle) / divisor, normpdf((i - l_points_middle) / divisor, l_average, l_deviation)/divisor);
    DBMS_OUTPUT.PUT_LINE('X: ' || (i - l_points_middle) / divisor || ' Y: ' || normpdf((i - l_points_middle) / divisor, l_average, l_deviation)/divisor);
  END LOOP;

  RETURN result;
END calculate_normpdf;
/
create or replace FUNCTION erfcc(x in NUMBER) RETURN NUMBER IS
    z NUMBER;
    t NUMBER;
    res NUMBER;
BEGIN
    z := ABS(x) / SQRT(2);
    t := 1.0 / (1.0 + 0.5 * z);
    res := t * EXP(-z * z - 1.26551223 + 
                    t * (1.00002368 +
                    t * (0.37409196 + 
                    t * (0.09678418 +
                    t * (-0.18628806 +
                    t * (0.27886807 +
                    t * (-1.13520398 +
                    t * (1.48851587 +
                    t * (-0.82215223 +
                    t * 0.17087277)))))))));

RETURN CASE WHEN x >= 0.0 THEN res ELSE 2.0 - res END;
END erfcc;
/
create or replace FUNCTION "NEXT_PRODUCED_MODEL_SERIAL_NUMBER" (p_id_modelu in number )
RETURN VARCHAR2
AS
    next_code varchar2(30);
BEGIN
    SELECT concat(m.podstawowy_kod, (
        SELECT to_char(count(id_modelu), 'FM00000000') 
        FROM produkcja WHERE id_modelu = p_id_modelu)) 
    INTO next_code
    FROM modele m
    WHERE id_modelu = p_id_modelu;
    return next_code;
exception
    when no_data_found then
        apex_debug.warn(
            p_message => 'Brak modelu. p_id_modelu %s, sqlerrm %s',
            p0        => p_id_modelu,
            p1        => sqlerrm );
        raise;
END "NEXT_PRODUCED_MODEL_SERIAL_NUMBER";
/
create or replace FUNCTION "NEXT_PRODUCED_NUMBER" (p_id_modelu in number )
RETURN VARCHAR2
AS
    next_code varchar2(30);
BEGIN
    SELECT concat(m.podstawowy_kod, (
        SELECT to_char(count(id_modelu), 'FM00000000') 
        FROM produkcja WHERE id_modelu = p_id_modelu)) 
    INTO next_code
    FROM modele m
    WHERE id_modelu = p_id_modelu;
    return next_code;
exception
    when no_data_found then
        apex_debug.warn(
            p_message => 'Brak modelu. p_id_modelu %s, sqlerrm %s',
            p0        => p_id_modelu,
            p1        => sqlerrm );
        raise;
END "NEXT_PRODUCED_NUMBER";
/
create or replace FUNCTION normcdf(x IN NUMBER, mean IN NUMBER, deviation IN NUMBER)
RETURN NUMBER IS
BEGIN
  RETURN 0.5 * (2 - erfcc((x - mean) / (SQRT(2) * deviation)));
END normcdf;
/
create or replace FUNCTION normcdf2(x number, mu number, sigma number) RETURN number IS
  z NUMBER;
  t NUMBER;
  erf NUMBER;
BEGIN
  z := (x - mu) / (sigma * sqrt(2));
  t  := 1.0 / (1.0 + 0.5 * abs(z));
  erf := 1 - t * exp( -z*z -  1.26551223
                                  + t * ( 1.00002368
                                  + t * ( 0.37409196
                                  + t * ( 0.09678418
                                  + t * (-0.18628806
                                  + t * ( 0.27886807
                                  + t * (-1.13520398
                                  + t * ( 1.48851587
                                  + t * (-0.82215223
                                  + t * ( 0.17087277))))))))));
  RETURN 0.5 * (1 + sign(z) * erf);
END;
/
create or replace FUNCTION norminv(p IN NUMBER, mean IN NUMBER, deviation IN NUMBER) RETURN NUMBER AS 
  a1 NUMBER := -39.6968302866538;
  a2 NUMBER := 220.946098424521;
  a3 NUMBER := -275.928510446969;
  a4 NUMBER := 138.357751867269;
  a5 NUMBER := -30.6647980661472;
  a6 NUMBER := 2.50662827745924;
  
  b1 NUMBER := -54.4760987982241;
  b2 NUMBER := 161.585836858041;
  b3 NUMBER := -155.698979859887;
  b4 NUMBER := 66.8013118877197;
  b5 NUMBER := -13.2806815528857;
  
  c1 NUMBER := -7.78489400243029E-03;
  c2 NUMBER := -0.322396458041136;
  c3 NUMBER := -2.40075827716184;
  c4 NUMBER := -2.54973253934373;
  c5 NUMBER := 4.37466414146497;
  c6 NUMBER := 2.93816398269878;
  
  d1 NUMBER := 7.78469570904146E-03;
  d2 NUMBER := 0.32246712907004;
  d3 NUMBER := 2.445134137143;
  d4 NUMBER := 3.75440866190742;
  
  p_low NUMBER := 0.02425;
  p_high NUMBER := 1 - p_low;
  
  q NUMBER;
  r NUMBER;
  e NUMBER;
  u NUMBER;
  
BEGIN
  IF p < 0 OR p > 1 THEN
    RETURN NULL;
  ELSIF p = 0 THEN
    RETURN -1E30;
  ELSIF p = 1 THEN
    RETURN 1E30;
  ELSIF p < p_low THEN
    q := sqrt(-2*ln(p));
    RETURN mean + deviation * (((((c1*q+c2)*q+c3)*q+c4)*q+c5)*q+c6);
  ELSIF p <= p_high THEN
    q := p - 0.5;
    r := q*q;
    RETURN mean + deviation * (((((a1*r+a2)*r+a3)*r+a4)*r+a5)*r+a6*q);
  ELSE
    q := sqrt(-2*ln(1-p));
    RETURN mean - deviation * (((((b1*q+b2)*q+b3)*q+b4)*q+b5)*q+1);
  END IF;
END;
/
create or replace FUNCTION normpdf (x NUMBER, mean NUMBER, stddeviation NUMBER)
RETURN NUMBER IS
  pi CONSTANT NUMBER := 3.14159265358979323846;
  e  CONSTANT NUMBER := 2.71828182845904523536;
BEGIN
  RETURN (1 / (stddeviation * SQRT(2 * pi))) * POWER(e, -1 * (POWER((x - mean), 2) / (2 * POWER(stddeviation, 2))));
END normpdf;
/






































  CREATE UNIQUE INDEX "KATALOG_PK" ON "KATALOG" ("ID_CZĘŚCI") 
  ;

  CREATE UNIQUE INDEX "MODELE_PK" ON "MODELE" ("ID_MODELU") 
  ;

  CREATE UNIQUE INDEX "PRODUKCJA_PK" ON "PRODUKCJA" ("ID_PRODUKCJA") 
  ;

  CREATE UNIQUE INDEX "SPECYFIKACJE_PK" ON "SPECYFIKACJE" ("ID_SPECYFIKACJI") 
  ;

































































































   CREATE SEQUENCE  "DEPT_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 50 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;

   CREATE SEQUENCE  "EMP_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 8000 CACHE 20 NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;

   CREATE SEQUENCE  "PROD_ID_SEQ"  MINVALUE 1 MAXVALUE 9999999999999999999999999999 INCREMENT BY 1 START WITH 101 NOCACHE  NOORDER  NOCYCLE  NOKEEP  NOSCALE  GLOBAL ;




























create or replace trigger "PRODUKCJA_CREATION_T"
before insert on "PRODUKCJA"
for each row
begin
    SELECT NEXT_PRODUCED_NUMBER(:new.id_modelu) INTO :NEW.nr_seryjny FROM dual;
end;
/





















  CREATE OR REPLACE FORCE EDITIONABLE VIEW "CZĘŚCI_SPECYFIKACJE_PRODUKCJA_USED_COUNT_V" ("Ilość", "Nazwa części") AS 
  SELECT sum(s.ilość) as "Ilość", k.opis as "Nazwa części" FROM katalog k
INNER JOIN specyfikacje s on s.id_części = k.id_części
INNER JOIN produkcja p on s.id_modelu = p.id_modelu
group by k.id_części, k.opis;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "HOURLY_PRODUCTION_OBJECT_V" ("NAZWA", "SUMA", "GODZINA") AS 
  SELECT m.opis Nazwa, count(m.id_modelu) Suma, 
to_char(TRUNC(p.data,'HH24'), 'HH') Godzina
FROM produkcja p
INNER JOIN modele m on p.id_modelu = m.id_modelu  
WHERE p.data BETWEEN systimestamp - INTERVAL '1' DAY AND systimestamp
group by m.id_modelu, m.opis, TRUNC(data, 'HH24');

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "HOURLY_PRODUCTION_USAGE_V" ("NAZWA", "SUMA", "GODZINA") AS 
  SELECT k.opis Nazwa, sum(s.ilość) Suma, to_char(TRUNC(p.data,'HH24'), 'HH') Godzina
FROM produkcja p
INNER JOIN specyfikacje s on s.id_modelu = p.id_modelu
INNER JOIN katalog k on s.id_części = k.id_części  
WHERE p.data BETWEEN systimestamp - INTERVAL '1' DAY AND systimestamp
group by k.id_części, k.opis, TRUNC(data, 'HH24');

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "MODELE_PRODUKCJA_COUNT_V" ("LICZBA", "MODEL", "ID_MODELU") AS 
  SELECT count(m.id_modelu) as Liczba, m.opis as Model, m.id_modelu as ID_MODELU FROM modele m
INNER JOIN produkcja p on p.id_modelu = m.id_modelu
GROUP BY m.id_modelu, m.opis;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "MV_PRODUCTION_AVG_DEVIATION" ("ID_MODELU", "X", "Y") AS 
  SELECT 
    ID_MODELU,
  (level - 101) / 10 as x, 
  normpdf((level - 101) / 10, ptaad.CURAVERAGE, ptaad.CURDEVIATION) as y
FROM PRODUCTION_TOTAL_AVERAGE_AND_DEVIATION_V ptaad
WHERE ptaad.CURDEVIATION != 0
CONNECT BY level <= 201;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCED_MODEL_V" ("OPIS", "NR_SERYJNY", "ID_MODELU", "DATA") AS 
  select MODELE.OPIS as OPIS,
    PRODUKCJA.NR_SERYJNY as NR_SERYJNY,
    PRODUKCJA.ID_MODELU as ID_MODELU,
    PRODUKCJA.DATA as DATA 
 from PRODUKCJA PRODUKCJA,
    MODELE MODELE 
 where PRODUKCJA.ID_MODELU=MODELE.ID_MODELU;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCTION_COUNT_DATES_V" ("ID_MODELU", "DATES", "CNT") AS 
  SELECT m.id_modelu,
       ptdv.dates,
       COALESCE(Count(p.id_modelu), 0) AS cnt
FROM modele m
CROSS JOIN PRODUCTION_TOTAL_DATE_RANGE_V ptdv
LEFT JOIN produkcja p ON m.id_modelu = p.id_modelu AND TRUNC(p.data) = ptdv.dates
GROUP BY m.id_modelu, ptdv.dates
ORDER BY m.id_modelu, ptdv.dates;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCTION_COUNT_MONTHLY_V" ("ID_MODELU", "MONTH", "MONTHLYTOTAL") AS 
  SELECT ID_MODELU, 
       TO_CHAR(DATES, 'YYYY-MM') AS Month, 
       SUM(CNT) AS MonthlyTotal
FROM PRODUCTION_COUNT_DATES_V
GROUP BY ID_MODELU, TO_CHAR(DATES, 'YYYY-MM')
ORDER BY ID_MODELU, Month;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCTION_CUMSUM_CZĘŚCI_V" ("ID_CZĘŚCI", "DATES", "CNT", "CUMULATIVE_CNT") AS 
  SELECT
    id_części,
    dates,
    cnt,
    SUM(cnt) OVER (
        PARTITION BY id_części 
        ORDER BY TO_DATE(dates, 'MM/DD/YYYY')
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS cumulative_cnt
FROM
    PRODUCTION_USAGE_CZĘŚCI_V
ORDER BY
    id_części,
    TO_DATE(dates, 'MM/DD/YYYY');

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCTION_CUMULATIVE_SUM_V" ("ID_MODELU", "DATES", "CUMULATIVESUM") AS 
  SELECT m.id_modelu,
       ptdv.dates,
       SUM(COALESCE(Count(p.id_modelu), 0)) OVER (PARTITION BY m.id_modelu ORDER BY ptdv.dates) AS cumulativesum
FROM modele m
CROSS JOIN PRODUCTION_TOTAL_DATE_RANGE_V ptdv
LEFT JOIN produkcja p ON m.id_modelu = p.id_modelu AND TRUNC(p.data) = ptdv.dates
GROUP BY m.id_modelu, ptdv.dates
ORDER BY m.id_modelu, ptdv.dates;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCTION_DATE_RANGE_V" ("MIN_DATE", "MAX_DATE") AS 
  SELECT TRUNC(MIN(data)) AS min_date, TRUNC(SYSDATE) AS max_date
  FROM produkcja;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCTION_TOTAL_AVERAGE_AND_DEVIATION_V" ("ID_MODELU", "CURAVERAGE", "CURDEVIATION", "MAXDATE") AS 
  SELECT ID_MODELU, 
AVG(CNT) CurAverage,
STDDEV(CNT) CurDeviation,
MAX(DATES) MaxDate
FROM PRODUCTION_COUNT_DATES_V
group by ID_MODELU;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCTION_TOTAL_DATE_RANGE_V" ("DATES") AS 
  select TRUNC(min_date + (LEVEL - 1)) AS dates FROM PRODUCTION_DATE_RANGE_V CONNECT BY LEVEL <= max_date - min_date + 1;

  CREATE OR REPLACE FORCE EDITIONABLE VIEW "PRODUCTION_USAGE_CZĘŚCI_V" ("ID_CZĘŚCI", "DATES", "CNT") AS 
  SELECT 
  c.id_części,
  d.dates,
  COALESCE(p.cnt, 0) AS cnt
FROM 
  (
    SELECT DISTINCT id_części 
    FROM specyfikacje
  ) c 
CROSS JOIN 
  (
    SELECT dates 
    FROM PRODUCTION_TOTAL_DATE_RANGE_V
  ) d
LEFT JOIN 
  (
    SELECT 
      s.id_części,
      TO_CHAR(p.data, 'MM/DD/YYYY') AS dates,
      SUM(s.ilość) AS cnt
    FROM 
      produkcja p 
    JOIN 
      specyfikacje s ON p.id_modelu = s.id_modelu
    GROUP BY 
      s.id_części, 
      TO_CHAR(p.data, 'MM/DD/YYYY')
  ) p ON c.id_części = p.id_części AND d.dates = p.dates
ORDER BY 
  c.id_części, 
  TO_DATE(d.dates, 'MM/DD/YYYY');

  CREATE OR REPLACE EDITIONABLE TRIGGER "PRODUKCJA_CREATION_T" 
before insert on "PRODUKCJA"
for each row
begin
    SELECT NEXT_PRODUCED_NUMBER(:new.id_modelu) INTO :NEW.nr_seryjny FROM dual;
end;
/
ALTER TRIGGER "PRODUKCJA_CREATION_T" ENABLE;





























create or replace TYPE forecast_table_type AS TABLE OF forecast_type
/
create or replace TYPE forecast_type AS OBJECT (
  forecast_date DATE,
  forecasted_value NUMBER
)
/
create or replace TYPE forecast_with_limits_table_type AS TABLE OF forecast_with_limits_type
/
create or replace TYPE forecast_with_limits_type AS OBJECT (
  limit_type VARCHAR2(10),
  forecast_date DATE,
  forecasted_value NUMBER
)
/
create or replace TYPE point_table_type AS TABLE OF point_type
/
create or replace TYPE point_type AS OBJECT (
  x NUMBER,
  y NUMBER
)
/















  CREATE UNIQUE INDEX "KATALOG_PK" ON "KATALOG" ("ID_CZĘŚCI") 
  ;

  CREATE UNIQUE INDEX "MODELE_PK" ON "MODELE" ("ID_MODELU") 
  ;

  CREATE UNIQUE INDEX "PRODUKCJA_PK" ON "PRODUKCJA" ("ID_PRODUKCJA") 
  ;

  CREATE OR REPLACE EDITIONABLE TRIGGER "PRODUKCJA_CREATION_T" 
before insert on "PRODUKCJA"
for each row
begin
    SELECT NEXT_PRODUCED_NUMBER(:new.id_modelu) INTO :NEW.nr_seryjny FROM dual;
end;
/
ALTER TRIGGER "PRODUKCJA_CREATION_T" ENABLE;

  CREATE UNIQUE INDEX "SPECYFIKACJE_PK" ON "SPECYFIKACJE" ("ID_SPECYFIKACJI") 
  ;































































































